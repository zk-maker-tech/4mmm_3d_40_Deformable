
define read_from_file(name)
    local f, data0, data, m, i, line, line_sim, line_spl

    ; 打开文件
    f = file.open(name, 'r')
    data0 = file.read(f)
    file.close(f)

    ; 初始化返回数据列表
    data = list
    m = list.size(data0)

    ; 调试：输出总行数
    ;io.out("Total lines in file: " + string(m))

    ; 跳过标题行，从第2行开始
    loop i (2, m)
        line = data0(i)
        line_sim = string.simplify(line)
        line_spl = string.split(line_sim, ',')
        
        ; 调试：输出解析过程
        ;io.out("Line " + string(i-1) + " raw: " + line)
        ;io.out("Line " + string(i-1) + " simplified: " + line_sim)
        ;io.out("Line " + string(i-1) + " split: " + string(line_spl))

        if list.size(line_spl) >= 4 then
            data('end') = line_spl
        else
            io.out("Warning: Skipping invalid line " + string(i-1))
        endif
    end_loop

    ;io.out("Parsed data size: " + string(list.size(data)))
    ;io.out("Parsed data: " + string(data))

    return data
end


[read_from_file("points.txt")]


define filter_data(input_data,zorq)
    local data, i, row, name
    
    ; 初始化返回数据列表
    data = list
  
    ; 获取输入数据大小
    local size = list.size(input_data)
    
    ; 遍历每一行数据
    loop i (1, size)
        row = input_data(i)
        io.out("---------------------- " + row(1) + "," + row(2) + "," + row(3) + "," + row(4))
        ; 获取第一列（名称列）
        name = string.upper(row(1))
        zorq = string.upper(zorq)
        ; 检查名称中是否包含"orq
        if string.find(name, zorq) > 0 then
            data('end') = row
            ; 将row的元素拼接为字符串
            ;local row_str = row(1) + "," + row(2) + "," + row(3) + "," + row(4)
            ;io.out("Found  data: " + row_str)
        endif
    end_loop
    
    ;io.out("Total Z data found: " + string(list.size(filtered)))
    return data
end

; 修改后的 get_disp2 函数
fish define get_disp2(data_file,zorq)
  
     ; 从文件中读取数据
    local data = read_from_file(data_file)
    local points_data = filter_data(data,zorq)
   
    local num_points = list.size(points_data)
    
      ; 创建30x3的数组用于存储监测点坐标
    monitor_points = array(num_points, 3)  ; 30个点，每个点有3个坐标值 (X, Y, Z)
    
    
    ; 检查是否正好有30个点
    if num_points != 30 then
        io.out("Error: Expected 30 points, but found " + string(num_points) + " points in file")
        exit
    endif
    
    ; 填充 monitor_points 数组
    loop local i (1, num_points)
        local row = points_data(i)  ; 获取第i行数据
        ; row(2), row(3), row(4) 分别是 X, Y, Z 坐标，转换为浮点数
        monitor_points(i, 1) = float(row(2))  ; X 坐标
        monitor_points(i, 2) = float(row(3))  ; Y 坐标
        monitor_points(i, 3) = float(row(4))  ; Z 坐标
    end_loop
    
    ; 遍历所有监测点（保持原有逻辑）
    loop local j (1, num_points)
        local x = monitor_points(j, 2)
        local y = monitor_points(j, 1)
        local z = monitor_points(j, 3)
        
        ; 找到最近的网格点
        local p = block.gp.near(x, y, z)
        
        if p == null then
            ;io.out("Warning: 无法找到坐标 (" + string(x) + ", " + string(y) + ", " + string(z) + ") 的网格点")
            table('top'+zorq, y) = 0
        else
            table('top'+zorq, y) = block.gp.disp.z(p)
        endif
    end_loop
end


[get_disp2("points.txt","z")]
fish define test_filter(data_file)
    local data = read_from_file(data_file)
 
    local points_data = filter_data(data,"z")
    local num_points = list.size(points_data)
    io.out(num_points)
    loop local i (1, num_points)
        local row = points_data(i)  ; 获取第i行数据
        local row_str = row(1) + "," + row(2) + "," + row(3) + "," + row(4)
        io.out("Found  data: " + row_str)
    endloo
    
end
;[test_filter("points.txt")]