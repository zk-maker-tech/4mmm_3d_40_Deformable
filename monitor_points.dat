model new
model restore 'mmm2.2'

block gridpoint initialize displacement-x 0
block gridpoint initialize displacement-y 0
block gridpoint initialize displacement-z 0
block gridpoint initialize velocity-x 0
block gridpoint initialize velocity-y 0
block gridpoint initialize velocity-z 0

model large-strain on

define read_from_file(name)
    local f, data0, data, m, i, line, line_sim, line_spl

    ; 打开文件
    f = file.open(name, 'r')
    data0 = file.read(f)
    file.close(f)

    ; 初始化返回数据列表
    data = list
    m = list.size(data0)

    ; 调试：输出总行数
    io.out("Total lines in file: " + string(m))

    ; 跳过标题行，从第2行开始
    loop i (2, m)
        line = data0(i)
        line_sim = string.simplify(line)
        line_spl = string.split(line_sim, ',')
        
        ; 调试：输出解析过程
        ;io.out("Line " + string(i-1) + " raw: " + line)
        ;io.out("Line " + string(i-1) + " simplified: " + line_sim)
        ;io.out("Line " + string(i-1) + " split: " + string(line_spl))

        if list.size(line_spl) >= 4 then
            data('end') = line_spl
        else
            io.out("Warning: Skipping invalid line " + string(i-1))
        endif
    end_loop

    io.out("Parsed data size: " + string(list.size(data)))
    io.out("Parsed data: " + string(data))

    return data
end

define read_and_create_monitor_histories(filename)
    ; 读取文件
    local data = read_from_file(filename)
    local num_points = list.size(data)  ; 减去标题行
    local monitor_points = array(num_points, 3)  ; 动态分配数组大小
    local point_names = array(num_points)       ; 存储点名称
    ; 跳过标题行，从第2行开始
    loop local i (1, list.size(data))
        local line = data(i)                    ; 获取每行数据
        local idx = i - 1                       ; 数组索引从1开始
        point_names(i) = line(1)              ; 第1列为名称
        monitor_points(i, 2) = float(line(2)) ; 第2列为x
        monitor_points(i, 1) = float(line(3)) ; 第3列为y
        monitor_points(i, 3) = float(line(4)) ; 第4列为z
       
    end_loop
    ; 创建历史记录
    loop local j (1, num_points)
        local x = monitor_points(j, 1)
        local y = monitor_points(j, 2)
        local z = monitor_points(j, 3)
        local name = point_names(j)
        io.out("Point " + name + ": x=" + string(x) + ", y=" + string(y,0,'',3,'f') + ", z=" + string(z))
        ; 检查最近的网格点是否存在
        local gp = block.gp.near(x, y, z)
        if gp = 0 then
            io.out("Skipping " + name + " at (" + string(x) + ", " + string(y,0,'',3,'f') + ", " + string(z) + ") - No gridpoint found")
            continue  ; 跳过此点，继续下一个
        endif
        io.out("Creating history for " + name + " at " + string(x) + "," + string(y,0,'',3,'f') + "," + string(z))
        command 
            block history name @name  displacement-z position @x @y @z
        endcommand
       
    end_loop

    ; 可选：返回数据以供检查
    return monitor_points
end

; 调用函数，假设文件名为 points.txt
[read_and_create_monitor_histories("points.txt")]


;model solve ratio 1e-4
model save 'monitor_points'